#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
🛡️ Bitrix24 Vulnerability Scanner
Автоматическое сканирование уязвимостей корпоративного портала Битрикс24
Author: AKUMA
Version: 1.0
"""

import requests
import ssl
import socket
import subprocess
import json
import sys
import os
from urllib.parse import urljoin, urlparse
import xml.etree.ElementTree as ET
from datetime import datetime
import concurrent.futures
import argparse

class Colors:
    RED = '\033[0;31m'
    YELLOW = '\033[1;33m'
    GREEN = '\033[0;32m'
    BLUE = '\033[0;34m'
    PURPLE = '\033[0;35m'
    CYAN = '\033[0;36m'
    WHITE = '\033[1;37m'
    NC = '\033[0m'  # No Color

class Bitrix24Scanner:
    def __init__(self, target_url, timeout=10):
        self.target_url = target_url.rstrip('/')
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        self.vulnerabilities = []
        self.info_gathered = {}
        
    def print_banner(self):
        banner = f"""
{Colors.CYAN}╔══════════════════════════════════════════════════════════════════════════════╗
║                    🛡️  Bitrix24 Security Scanner                              ║
║                           Author: AKUMA v1.0                                 ║
╚══════════════════════════════════════════════════════════════════════════════╝{Colors.NC}

{Colors.YELLOW}🎯 Target: {Colors.WHITE}{self.target_url}{Colors.NC}
{Colors.YELLOW}📅 Scan Date: {Colors.WHITE}{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}{Colors.NC}
"""
        print(banner)

    def check_connection(self):
        """Проверка доступности цели"""
        try:
            response = self.session.get(self.target_url, timeout=self.timeout, allow_redirects=True)
            if response.status_code == 200:
                print(f"{Colors.GREEN}✅ Target is accessible{Colors.NC}")
                return True
            else:
                print(f"{Colors.YELLOW}⚠️  Target returned status code: {response.status_code}{Colors.NC}")
                return True
        except requests.exceptions.RequestException as e:
            print(f"{Colors.RED}❌ Cannot reach target: {e}{Colors.NC}")
            return False

    def detect_bitrix(self):
        """Определение, что это действительно Битрикс"""
        print(f"\n{Colors.BLUE}🔍 Detecting Bitrix24...{Colors.NC}")
        
        bitrix_indicators = [
            '/bitrix/admin/',
            '/bitrix/tools/',
            '/bitrix/js/',
            '/bitrix/css/',
            '/bitrix/components/',
            '/upload/iblock/',
            '/local/templates/'
        ]
        
        detected = False
        for path in bitrix_indicators:
            try:
                url = urljoin(self.target_url, path)
                response = self.session.get(url, timeout=self.timeout)
                if response.status_code in [200, 403, 301]:
                    print(f"{Colors.GREEN}✅ Found Bitrix indicator: {path}{Colors.NC}")
                    detected = True
                    break
            except:
                continue
        
        # Проверка заголовков и содержимого
        try:
            response = self.session.get(self.target_url)
            headers = response.headers
            content = response.text.lower()
            
            if 'bitrix' in content or 'bitrix24' in content:
                print(f"{Colors.GREEN}✅ Bitrix detected in content{Colors.NC}")
                detected = True
            
            if 'x-powered-cms' in headers and 'bitrix' in headers.get('x-powered-cms', '').lower():
                print(f"{Colors.GREEN}✅ Bitrix detected in headers{Colors.NC}")
                detected = True
                
        except:
            pass
            
        if detected:
            print(f"{Colors.GREEN}🎯 Bitrix24 detected successfully{Colors.NC}")
        else:
            print(f"{Colors.YELLOW}⚠️  Bitrix24 not clearly detected, continuing anyway{Colors.NC}")
            
        return detected

    def check_ssl_security(self):
        """Проверка SSL/TLS конфигурации"""
        print(f"\n{Colors.BLUE}🔒 SSL/TLS Security Check...{Colors.NC}")
        
        parsed_url = urlparse(self.target_url)
        hostname = parsed_url.hostname
        port = parsed_url.port or (443 if parsed_url.scheme == 'https' else 80)
        
        if parsed_url.scheme != 'https':
            self.vulnerabilities.append({
                'type': 'SSL',
                'severity': 'HIGH',
                'description': 'Site not using HTTPS',
                'recommendation': 'Enable HTTPS and redirect HTTP to HTTPS'
            })
            print(f"{Colors.RED}❌ HTTPS not enabled{Colors.NC}")
            return
        
        try:
            # Проверка SSL сертификата
            context = ssl.create_default_context()
            with socket.create_connection((hostname, port), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Проверка срока действия
                    not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_left = (not_after - datetime.now()).days
                    
                    if days_left < 30:
                        self.vulnerabilities.append({
                            'type': 'SSL',
                            'severity': 'HIGH',
                            'description': f'SSL certificate expires in {days_left} days',
                            'recommendation': 'Renew SSL certificate'
                        })
                        print(f"{Colors.RED}❌ SSL certificate expires soon: {days_left} days{Colors.NC}")
                    else:
                        print(f"{Colors.GREEN}✅ SSL certificate valid for {days_left} days{Colors.NC}")
                    
                    # Проверка алгоритма подписи
                    tls_version = ssock.version()
                    print(f"{Colors.CYAN}ℹ️  TLS Version: {tls_version}{Colors.NC}")
                    
                    if tls_version in ['TLSv1', 'TLSv1.1']:
                        self.vulnerabilities.append({
                            'type': 'SSL',
                            'severity': 'MEDIUM',
                            'description': f'Weak TLS version: {tls_version}',
                            'recommendation': 'Upgrade to TLS 1.2 or higher'
                        })
                        
        except Exception as e:
            print(f"{Colors.RED}❌ SSL check failed: {e}{Colors.NC}")

    def check_common_vulnerabilities(self):
        """Проверка общих уязвимостей"""
        print(f"\n{Colors.BLUE}🐛 Common Vulnerabilities Check...{Colors.NC}")
        
        # Проверка административных панелей
        admin_paths = [
            '/bitrix/admin/',
            '/bitrix/admin/index.php',
            '/bitrix/admin/user_admin.php',
            '/bitrix/admin/menu.php'
        ]
        
        for path in admin_paths:
            try:
                url = urljoin(self.target_url, path)
                response = self.session.get(url, timeout=self.timeout)
                
                if response.status_code == 200 and 'login' in response.text.lower():
                    print(f"{Colors.YELLOW}⚠️  Admin panel accessible: {path}{Colors.NC}")
                    self.vulnerabilities.append({
                        'type': 'ACCESS_CONTROL',
                        'severity': 'MEDIUM',
                        'description': f'Admin panel accessible at {path}',
                        'recommendation': 'Restrict admin panel access by IP or implement additional authentication'
                    })
            except:
                continue
        
        # Проверка директорий с чувствительной информацией
        sensitive_paths = [
            '/bitrix/backup/',
            '/bitrix/logs/',
            '/bitrix/cache/',
            '/bitrix/managed_cache/',
            '/local/logs/',
            '/.git/',
            '/bitrix/.settings.php'
        ]
        
        for path in sensitive_paths:
            try:
                url = urljoin(self.target_url, path)
                response = self.session.get(url, timeout=self.timeout)
                
                if response.status_code == 200:
                    print(f"{Colors.RED}❌ Sensitive directory exposed: {path}{Colors.NC}")
                    self.vulnerabilities.append({
                        'type': 'INFORMATION_DISCLOSURE',
                        'severity': 'HIGH',
                        'description': f'Sensitive directory exposed: {path}',
                        'recommendation': f'Restrict access to {path} directory'
                    })
                elif response.status_code == 403:
                    print(f"{Colors.GREEN}✅ Directory properly protected: {path}{Colors.NC}")
            except:
                continue

    def check_information_disclosure(self):
        """Проверка утечки информации"""
        print(f"\n{Colors.BLUE}📄 Information Disclosure Check...{Colors.NC}")
        
        info_paths = [
            '/phpinfo.php',
            '/info.php',
            '/test.php',
            '/bitrix/php_interface/dbconn.php',
            '/robots.txt',
            '/sitemap.xml'
        ]
        
        for path in info_paths:
            try:
                url = urljoin(self.target_url, path)
                response = self.session.get(url, timeout=self.timeout)
                
                if response.status_code == 200:
                    content = response.text.lower()
                    
                    if 'phpinfo()' in content or 'php version' in content:
                        print(f"{Colors.RED}❌ PHP info exposed: {path}{Colors.NC}")
                        self.vulnerabilities.append({
                            'type': 'INFORMATION_DISCLOSURE',
                            'severity': 'HIGH',
                            'description': f'PHP information exposed at {path}',
                            'recommendation': f'Remove or protect {path} file'
                        })
                    
                    elif path.endswith('.php') and ('error' in content or 'warning' in content):
                        print(f"{Colors.YELLOW}⚠️  PHP errors exposed: {path}{Colors.NC}")
                        self.vulnerabilities.append({
                            'type': 'INFORMATION_DISCLOSURE',
                            'severity': 'MEDIUM',
                            'description': f'PHP errors exposed at {path}',
                            'recommendation': 'Disable error reporting in production'
                        })
                    
                    elif path == '/robots.txt':
                        print(f"{Colors.CYAN}ℹ️  robots.txt found: {len(content)} bytes{Colors.NC}")
                        
            except:
                continue

    def check_bitrix_specific_vulns(self):
        """Проверка специфичных для Битрикс уязвимостей"""
        print(f"\n{Colors.BLUE}🎯 Bitrix-specific Vulnerabilities...{Colors.NC}")
        
        # Проверка старых версий компонентов
        component_paths = [
            '/bitrix/components/bitrix/system.auth.form/',
            '/bitrix/components/bitrix/forum/',
            '/bitrix/components/bitrix/catalog/',
            '/bitrix/js/main/core/',
        ]
        
        for path in component_paths:
            try:
                url = urljoin(self.target_url, path)
                response = self.session.get(url, timeout=self.timeout)
                
                if response.status_code == 200:
                    print(f"{Colors.CYAN}ℹ️  Component accessible: {path}{Colors.NC}")
            except:
                continue
        
        # Проверка конфигурационных файлов
        config_paths = [
            '/bitrix/.settings.php',
            '/bitrix/php_interface/dbconn.php',
            '/local/php_interface/init.php'
        ]
        
        for path in config_paths:
            try:
                url = urljoin(self.target_url, path)
                response = self.session.get(url, timeout=self.timeout)
                
                if response.status_code == 200 and len(response.text) > 100:
                    print(f"{Colors.RED}❌ Config file accessible: {path}{Colors.NC}")
                    self.vulnerabilities.append({
                        'type': 'CONFIGURATION',
                        'severity': 'CRITICAL',
                        'description': f'Configuration file exposed: {path}',
                        'recommendation': f'Deny access to {path} via web server configuration'
                    })
            except:
                continue

    def check_security_headers(self):
        """Проверка заголовков безопасности"""
        print(f"\n{Colors.BLUE}🛡️  Security Headers Check...{Colors.NC}")
        
        try:
            response = self.session.get(self.target_url)
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection',
                'X-Content-Type-Options': 'MIME type sniffing protection',
                'X-XSS-Protection': 'XSS filter',
                'Strict-Transport-Security': 'HTTPS enforcement',
                'Content-Security-Policy': 'Content injection protection',
                'Referrer-Policy': 'Referrer information control'
            }
            
            for header, description in security_headers.items():
                if header.lower() in [h.lower() for h in headers.keys()]:
                    print(f"{Colors.GREEN}✅ {header}: {description}{Colors.NC}")
                else:
                    print(f"{Colors.YELLOW}⚠️  Missing {header}: {description}{Colors.NC}")
                    self.vulnerabilities.append({
                        'type': 'SECURITY_HEADERS',
                        'severity': 'MEDIUM',
                        'description': f'Missing security header: {header}',
                        'recommendation': f'Add {header} header for {description}'
                    })
                    
        except Exception as e:
            print(f"{Colors.RED}❌ Headers check failed: {e}{Colors.NC}")

    def generate_report(self):
        """Генерация отчета"""
        print(f"\n{Colors.PURPLE}📊 SCAN RESULTS{Colors.NC}")
        print("=" * 50)
        
        if not self.vulnerabilities:
            print(f"{Colors.GREEN}🎉 No vulnerabilities found!{Colors.NC}")
            return
        
        # Группировка по уровню серьезности
        critical = [v for v in self.vulnerabilities if v['severity'] == 'CRITICAL']
        high = [v for v in self.vulnerabilities if v['severity'] == 'HIGH']
        medium = [v for v in self.vulnerabilities if v['severity'] == 'MEDIUM']
        low = [v for v in self.vulnerabilities if v['severity'] == 'LOW']
        
        print(f"{Colors.RED}🔥 Critical: {len(critical)}{Colors.NC}")
        print(f"{Colors.YELLOW}⚠️  High: {len(high)}{Colors.NC}")
        print(f"{Colors.BLUE}ℹ️  Medium: {len(medium)}{Colors.NC}")
        print(f"{Colors.GREEN}👍 Low: {len(low)}{Colors.NC}")
        
        print(f"\n{Colors.WHITE}DETAILED FINDINGS:{Colors.NC}")
        print("-" * 50)
        
        for i, vuln in enumerate(self.vulnerabilities, 1):
            severity_color = {
                'CRITICAL': Colors.RED,
                'HIGH': Colors.YELLOW,
                'MEDIUM': Colors.BLUE,
                'LOW': Colors.GREEN
            }.get(vuln['severity'], Colors.WHITE)
            
            print(f"\n{Colors.WHITE}{i}. [{vuln['type']}] {severity_color}{vuln['severity']}{Colors.NC}")
            print(f"   Description: {vuln['description']}")
            print(f"   Recommendation: {vuln['recommendation']}")
        
        # Сохранение в JSON
        report_data = {
            'target': self.target_url,
            'scan_date': datetime.now().isoformat(),
            'vulnerabilities': self.vulnerabilities,
            'summary': {
                'total': len(self.vulnerabilities),
                'critical': len(critical),
                'high': len(high),
                'medium': len(medium),
                'low': len(low)
            }
        }
        
        report_file = f"bitrix24_scan_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, ensure_ascii=False)
        
        print(f"\n{Colors.CYAN}📄 Report saved to: {report_file}{Colors.NC}")

    def run_scan(self):
        """Запуск полного сканирования"""
        self.print_banner()
        
        if not self.check_connection():
            return
        
        self.detect_bitrix()
        self.check_ssl_security()
        self.check_security_headers()
        self.check_common_vulnerabilities()
        self.check_information_disclosure()
        self.check_bitrix_specific_vulns()
        self.generate_report()

def main():
    parser = argparse.ArgumentParser(description='Bitrix24 Security Scanner')
    parser.add_argument('url', help='Target URL (e.g., https://example.com)')
    parser.add_argument('--timeout', type=int, default=10, help='Request timeout (default: 10)')
    
    args = parser.parse_args()
    
    scanner = Bitrix24Scanner(args.url, args.timeout)
    
    try:
        scanner.run_scan()
    except KeyboardInterrupt:
        print(f"\n{Colors.RED}❌ Scan interrupted by user{Colors.NC}")
        sys.exit(1)
    except Exception as e:
        print(f"\n{Colors.RED}❌ Scan failed: {e}{Colors.NC}")
        sys.exit(1)

if __name__ == "__main__":
    main()
